---
title: 'Copilot: Helping developers become engineers again'
pubDate: 2024-05-28
description: 'Some quick thoughts on how AI tools like Copilot helps developers.'
author: 'Sarah Guthals'
image:
    url: 'https://docs.astro.build/assets/full-logo-light.png'
    alt: 'The full Astro logo.'
tags: ["copilot", "musings", "devtools"]
---
# Copilot: Helping developers become engineers again

Published on: 2024-05-28

AI tools, like [Copilot](https://github.com/features/copilot), is a chance for developers
to start re-engaging in the part of software development that is more like engineering than
coding. 

## My teaching philosophy

I've always been a teacher. Whether I was making "lesson plans" and "homework" for "play school" with my 6-years-younger sister (which was very real math lessons with math homework at a level that she could engage with as a 4 year old when I was 10), tutoring in undergrad, teaching computer science at UC San Diego, or developing a curriculum and writing books for children 8-13 to learn to program, I have always been teaching and often teaching computer science. 

I was never focused on teaching "coding", however. I would often opt for block-based programming languages for novices (e.g. [Scratch](http://scratch.mit.edu/)) or applications that were less abstract (e.g. [Arduino](https://www.arduino.cc/)) because I wanted my students to understand *what* computers could do and *how* to make them do that. The syntax and specificities around things easily looked up were never a priority. Instead, I would teach students how to look them up. 

Now, I **do** think syntax and eventually growing from learning languages to production languages are critical if you want to become a professional developer, but when you're learning something new I think it is much more important to start with understanding the space. That's why my PhD dissertation was titled "How to design learning environments that enculturate novices" (and yes, enculturate is totally a word, specifically because I used it in the title of my dissertation).

## First thing you should know when learning to code

There was always one thing that I wanted any of my students to really understand about what it means to build software: The goal is to separate what a computer can do well and what humans can do well. Then, you let the computer do what it knows how to do, BETTER than a human. And what that leaves you, as the human, is the chance to focus your attention on things only humans can do. 

In my early days of teaching, this line was a lot less blurred. But it still holds true (which I'll get to later). In the early days, this was teaching that with simple sensors you could more accurately diagnose the health of a plant. That a photoelectric water sensor connected to a simple Arduino that will text you when you need to water your plant is better than you trying to remember to put your finger in the dirt and feel how damp the soil is. Or, like one of my favorite moments, a young person is interested in being a preschool teacher but is also interested in learning simple app making and you can show them how to write a small app that will allow students to sit with a tablet and headphones and practice reading when the teacher is engaged with other students. 

Now, do either of those replace botanists or teachers? No.

Do they completely remove the need for a human to play a *critical* role in the health of plants or education of children? Definitely not.

But what they do allow for is the human to spend less time trying to remember to feel dirt and more time learning how to help plants flourish even more by spending energy exploring how different access to sun affects different plants. And they create space for students to be able to continue practicing even when their teacher cannot be cloned but cannot help them 1:1, or allow the student to practice on the bus ride home. 

So when I would teach coding, yes, I would want my students to know the basics of the syntax of whatever language we were using. Like it's important to learn how to spell so that you can more quickly convey information through writing. But knowing how to spell and knowing how to code doesn't mean you never make mistakes, and with practice you will have more syntax and words at your disposal for faster coding or writing. 

But where I focused the majority of my teaching was on the ability to see beyond the lines of code that were being written in the editor. I focused on the goal of the application, or the creativity in solving a complex problem. I focused on pushing the boundaries of the frameworks we were using. I focused on my students doing what humans do best: creating.

## What does this have to do with Copilot?

Obviously AI has been a hot topic for a while. More recently, the power of models specific to developers have become more accurate and helpful. I'm going to be honest, up until now the AI tools weren't interesting enough for me to spend a ton of time exploring. Yeah, I tried a couple prompts to see if I could get some simple code written here and there, or I would try it out for writing English about technical topics. But it honestly didn't feel that productive compared to just doing it myself. 

But with the more powerful models coming out, and in particular the power of truly integrating AI into your dev environment in a way that *doesn't* break your dev workflow...**this** made me excited about trying them out. 

The examples of *working* AI for developers over the last ~5 or so months has made me...dare I say it...excited again. I think it all came to a head for me when I watched [April and Justin give a demo of how to extend GitHub Copilot](https://www.youtube.com/watch?v=RXaLlCeaBIA&list=PLlrxD0HtieHg9nel7cWGD0_nyjYtZfKEK) at Microsoft Build last week and I just realized the reason I'm so excited is because...for the first time in a while...I could see how this could go back to my first lesson:
Let computers do what they do best so you can focus on what humans do best. 

In this case, computers are good at grabbing and summarizing context of an issue from your favorite monitoring platform (*cough* Sentry *cough*) and recognizing where you are in VS Code and give you all of that in a way that you can focus on the how you *want* to fix the issue. And if you can't fix it in that moment, helps you create the issues on GitHub to get to it later. 

In short, it felt like we were getting back to what made me excited about going into computer science in the first place: being a problem solver and being creative. And to me...that's a huge win for our industry.